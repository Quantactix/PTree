#' AP-Tree to generate stochastic discount factor
#' @description This is the main function of AP-Tree cross sectional split, which paritions the universe of individual stock returns to generate leaf basis portfolios and stochastic discount factors.
#' @param R A vector of all individual stock returns, pooled of cross section and time series. The data do not need to be balanced.
#' @param Y Auxiliary vector, used in the split criterion of Y ~ Z * F, for boosting.
#' @param X Matrix of firm characteristics, should match each row of \eqn{R}.
#' @param Z Matrix of macro economic variables, should match each row of \eqn{R}.
#' @param portfolio_weight A vector of weight (e.g., value weight or equal weight) for each individual stock return when generate the leaf basis portfolio, should match each row of \eqn{R}.
#' @param loss_weight A vector of weight for each individual stock return in the loss function (split criterion), should match each row of \eqn{R}.
#' @param stocks A vector of index of stocks, should match each row of \eqn{R}.
#' @param months A vector of index of months, should match each row of \eqn{R}.
#' @param first_split_var A vector of indicies of variables being considered as the first split, corresponding to column index in \eqn{X} (count starting from zero).
#' @param second_split_var A vector of indicies of variables being considered as the second split, corresponding to column index in \eqn{X} (count starting from zero).
#' @param num_stocks Integer, number of stocks.
#' @param num_months Integer, number of months.
#' @param min_leaf_size Integer, minimal number of stocks in the leaf node, as stopping condition.
#' @param max_depth Integer, maximum depth of the tree, as stopping condition.
#' @param num_iter Integer, maximum number of iterations of the algorithm.
#' @param num_cutpoints Integer, number of cutpoint candidates for each characteristics, defined by quantiles of \eqn{X} variables.
#' @param eta Scalar, tuning parameter. When construct SDF, w <- w * eta + (1 - w) * equalweight. For regularization to equal weight.
#' @param equal_weight Bool, if TRUE, equal weight portfolios.
#' @param no_H Bool, if TRUE, no Ht in the split criterion, otherwise it is Y ~ Z * F + H.
#' @param abs_normalize Bool if TRUE, normalize leaf basis portfolio weight when constructing SDF by w <- w / sum(abs(w)).
#' @param weighted_loss Bool, if TRUE, the loss function (split criterion) has weights for each return data, work wth loss_weight input.
#' @param lambda_mean Scalar, the SDF is generated by (mu + lambda_mean) * (Sigma + lambda_cov)^-1.
#' @param lambda_cov Scalar, see above.
#' @param early_stop Bool, if TRUE, allow early stop if (split criterion after the new split) >= stopthreshold * (split criterion before the new split).
#' @param stop_threshold Scalar, should be smaller than 1, for early stop option.
#' @param lambda_ridge Scalar, optional if the split criterion is ridge regression.
#' @param a1 Scalar, regularization for tree structure, use default, not activated.
#' @param a2 Scalar, regularization for tree structure, use default, not activated.
#' @param list_K Matrix, regularization for tree structure, use default, not activated.
#' @param random_split Bool, default FALSE, use Sharpe ratio criteria; if TRUE, use random split criteria.
#' @export
PTree <- function(R, Y, X, Z, H, portfolio_weight, loss_weight, stocks, months, first_split_var, second_split_var, num_stocks, num_months, min_leaf_size, max_depth, num_iter, num_cutpoints, eta = 1.0, equal_weight = FALSE, no_H = FALSE, abs_normalize = FALSE, weighted_loss = FALSE, lambda_mean = 0, lambda_cov = 0, lambda_mean_factor = 0, lambda_cov_factor = 0, early_stop = FALSE, stop_threshold = 0.95, lambda_ridge = 0, a1 = 0.05, a2 = 1.0, list_K, random_split = FALSE) {
    R <- as.matrix(R)
    Y <- as.matrix(Y)
    X <- as.matrix(X)
    Z <- as.matrix(Z)
    H <- as.matrix(H)

    unique_months <- sort(unique(months))

    output <- PTree_cpp(R, Y, X, Z, H, portfolio_weight, loss_weight, stocks, months, unique_months, first_split_var, second_split_var, num_stocks, num_months, min_leaf_size, max_depth, num_iter, num_cutpoints, eta, equal_weight, no_H, abs_normalize, weighted_loss, lambda_mean, lambda_cov, lambda_mean_factor, lambda_cov_factor, early_stop, stop_threshold, lambda_ridge, a1, a2, list_K, random_split)

    class(output) <- "PTree"

    return(output)
}
